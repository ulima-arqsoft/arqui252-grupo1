> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.8. Temas Individuales (Parte 2)](../0.8.md) ‚Ä∫ [0.8.3. Integrante 3](0.8.3.md)

# 0.8.3. Integrante 3

# Bases de Datos Vectoriales
## 1. Desarrollo conceptual 

### ¬øQu√© es una base de datos vectorial?

Una **base de datos vectorial** es un sistema dise√±ado para almacenar, indexar y consultar vectores o representaciones num√©ricas de datos como texto, im√°genes, audio o video.

Estos vectores suelen ser generados por modelos de machine learning (por ejemplo, modelos de embeddings) que convierten el contenido en listas de n√∫meros donde la distancia matem√°tica entre vectores indica similitud sem√°ntica.

### ¬øPor qu√© se necesitan?

Los datos actuales son principalmente no estructurados: documentos, im√°genes, audios, videos, logs, mensajes, c√≥digo, etc. En este tipo de datos, la representaci√≥n tradicional (texto literal) es limitada para encontrar similitudes, por ejemplo:

- ‚Äúauto‚Äù y ‚Äúcarro‚Äù son palabras distintas pero significan lo mismo.

- Una imagen de un gato no comparte texto con otra imagen de gato.

Los embeddings resuelven esto al convertir cada elemento en un vector donde significados similares terminan cercanos entre s√≠.

Las bases vectoriales permiten consultas del tipo:

- ‚ÄúEncuentra documentos similares a este p√°rrafo.‚Äù

- ‚ÄúDevu√©lveme im√°genes parecidas a esta imagen.‚Äù

- ‚Äú¬øQu√© c√≥digo es parecido a este snippet?‚Äù

- ‚ÄúQu√© cliente tiene un comportamiento similar al actual?‚Äù

### Capacidades principales
En lugar de buscar coincidencias exactas como en SQL, las bases vectoriales permiten:

**1. B√∫squeda por similitud (similarity search)**

Encuentra los elementos m√°s cercanos a un vector de consulta usando m√©tricas como:

- Cosine similarity
- Euclidean distance
- Dot product

Esto se usa en buscadores sem√°nticos, recomendaciones y clasificaci√≥n.

**2. Recuperaci√≥n sem√°ntica (semantic search)**

A diferencia de un buscador tradicional, identifica resultados relevantes aunque no contengan las mismas palabras, bas√°ndose en significado.

**Ejemplo:**
    
**Consulta:**```‚Äú¬øC√≥mo enciendo la PC?‚Äù```

**Resultado relevante:**``` ‚ÄúPasos para iniciar un computador‚Äù```

**3. RAG (Retrieval Augmented Generation)**

Combina bases vectoriales con modelos generativos (LLMs).
La base vectorial recupera la informaci√≥n relevante con la cual el modelo genera respuestas precisas, actualizadas y con base en hechos.

Es la t√©cnica est√°ndar para:
- Chatbots empresariales
- Sistemas de preguntas y respuestas
- Asistentes conversacionales con conocimiento espec√≠fico
- An√°lisis e indexaci√≥n de documentos

**4. Clasificaci√≥n y clustering basados en embeddings**

Agrupa o clasifica elementos seg√∫n su posici√≥n en el espacio vectorial. Muy √∫til en:

- Clusterizaci√≥n de noticias o clientes
- Detecci√≥n de temas
- Segmentaci√≥n inteligente

**5. Recomendaci√≥n de contenido similar**

Motores de recomendaci√≥n basados en similitud sem√°ntica:
- Productos parecidos
- Pel√≠culas similares
- Art√≠culos relacionados
- Usuarios con comportamientos parecidos

### Ventajas

Ofrecen m√∫ltiples ventajas que las convierten en la soluci√≥n ideal para trabajar con datos no estructurados y sistemas de IA modernos. Su arquitectura est√° dise√±ada para escalar eficientemente, permitiendo manejar desde millones hasta miles de millones de vectores sin comprometer el rendimiento.

Adem√°s, incorporan t√©cnicas avanzadas de indexaci√≥n de alta velocidad (como HNSW, IVF o Product Quantization) que optimizan la b√∫squeda y reducen significativamente los tiempos de consulta en espacios de alta dimensi√≥n. 

Otra ventaja clave es su integraci√≥n natural con modelos de IA generativa y LLMs, ya que utilizan embeddings como representaci√≥n sem√°ntica unificada de cualquier tipo de contenido. Todo esto se combina para ofrecer alta precisi√≥n en b√∫squedas sem√°nticas, incluso en datos complejos o no estructurados como texto libre, im√°genes o audio.

### **Diagrama conceptual** (visualizaci√≥n del proceso)

Esquema que resume c√≥mo se organiza y consulta la informaci√≥n en un entorno vectorial

![Diagrama BDV](./images/DiagramaBDV.png)

## 2. Consideraciones t√©cnicas

Para este proyecto, las consideraciones t√©cnicas se centran en el uso de:

### 1. Pinecone como base de datos vectorial

**Pinecone** ofrece:

- Indexaci√≥n optimizada para b√∫squedas vectoriales de alta velocidad.

- Almacenamiento administrado y escalable.

- API simple para insertar, actualizar y consultar vectores.


### 2. Python como lenguaje principal**

**Python** ser√° usado para:

- Generar embeddings.

- Insertar vectores en Pinecone.

- Ejecutar consultas de similitud y procesar resultados.

### 3. Docker como entorno aislado de ejecuci√≥n

Se usa **Docker** para garantizar portabilidad y reproducibilidad:

- Ventajas del uso de Docker:
    - Paquetes y dependencias controladas.
    Ambiente consistente entre desarrollo y producci√≥n.
    Posibilidad de contenedores dedicados para Python + SDK de Pinecone.

- Componentes principales del contenedor Docker:
    - Python 
    - Dependencias: pinecone-client, librer√≠as de embeddings

### Requisitos previos
- Una cuenta en Pinecone.
- Variable de entorno PINECONE_API_KEY configurada en un archivo .env.

Ejemplo de .env:

```bash
PINECONE_API_KEY=tu_api_key_aqui
```


## 3. Demo 

Esta demo muestra c√≥mo construir un sistema de b√∫squeda sem√°ntica usando Pinecone (Vector DB), embeddings y una interfaz visual con Streamlit.
Permite cargar un dataset de pel√≠culas, generar embeddings, almacenarlos en Pinecone y realizar b√∫squedas inteligentes basadas en significado, no en coincidencia literal.
El proyecto se ejecuta completamente dentro de un contenedor Docker, garantizando portabilidad y facilidad de despliegue.

### C√≥digo

---
### Archivo app.py

**1. Configuraci√≥n Inicial y Carga de la Demo**

Este bloque configura Streamlit, la p√°gina y carga la clase principal MovieVectorDemo usando cach√© para evitar recargar todo cada vez.

```python
import streamlit as st
import pandas as pd
from movie_recommender import MovieVectorDemo

# Configurar p√°gina
st.set_page_config(
    page_title="Demo Pinecone - B√∫squeda Vectorial",
    page_icon="üé¨",
    layout="wide"
)

# Inicializar demo
@st.cache_resource
def init_demo():
    return MovieVectorDemo()

demo = init_demo()
```

**2. Sidebar ‚Äî Inicializaci√≥n Manual de la Base Vectorial**

Permite cargar por primera vez los datos a Pinecone.
Solo debe usarse cuando la base est√° vac√≠a o se quiere regenerar todo.

```python
# Sidebar
st.sidebar.header("Configuraci√≥n")

if st.sidebar.button("Inicializar Base de Datos"):
    with st.spinner("Subiendo datos a Pinecone..."):
        try:
            count = demo.upload_to_pinecone()
            st.sidebar.success(f"{count} pel√≠culas cargadas")
            st.cache_data.clear()   # Limpia cache para forzar recarga
        except Exception as e:
            st.sidebar.error(f"Error: {str(e)}")
```
![Main page](./images/principal.png)


**3. Pesta√±a ‚ÄúB√∫squeda Sem√°ntica‚Äù**

Este bloque recibe un texto en lenguaje natural, genera embeddings y consulta Pinecone para mostrar pel√≠culas similares.

```python
tab1, tab2, tab3 = st.tabs(["üîç B√∫squeda", "üìä Datos", "üìà Visualizaci√≥n"])

with tab1:
    st.header("B√∫squeda Sem√°ntica de Pel√≠culas")

    query = st.text_input(
        "Describe la pel√≠cula que buscas:",
        "pel√≠cula de ciencia ficci√≥n sobre realidad virtual"
    )

    top_k = st.slider("N√∫mero de resultados:", 1, 10, 3)

    if st.button("Buscar Pel√≠culas Similares"):
        with st.spinner("Buscando en la base vectorial..."):
            try:
                results = demo.search_similar_movies(query, top_k=top_k)

                st.subheader("üéØ Resultados de la B√∫squeda")
                for i, match in enumerate(results['matches']):
                    score = match['score']
                    metadata = match['metadata']

                    col1, col2 = st.columns([3, 1])
                    with col1:
                        st.write(f"**{i+1}. {metadata['title']}**")
                        st.write(f"**G√©nero:** {metadata['genre']}")
                        st.write(f"**Descripci√≥n:** {metadata['description']}")
                    with col2:
                        st.metric("Similitud", f"{score:.3f}")

                    st.divider()

            except Exception as e:
                st.error(f"Error en la b√∫squeda: {str(e)}")
```

![Busqueda peliculas](./images/BusquedaPeliculas.png)

**4. Pesta√±a ‚ÄúDatos‚Äù**

Muestra las pel√≠culas almacenadas en Pinecone y estad√≠sticas r√°pidas.

```python
with tab2:
    st.header("Base de Datos Vectorial")

    @st.cache_data
    def load_pinecone_data():
        try:
            return demo.get_all_movies_from_pinecone()
        except Exception as e:
            st.error(f"Error cargando desde Pinecone: {str(e)}")
            return pd.DataFrame()

    pinecone_df = load_pinecone_data()

    if not pinecone_df.empty:
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Pel√≠culas en Vector DB", len(pinecone_df))
        with col2:
            st.metric("G√©neros √önicos", pinecone_df['genre'].nunique())
        with col3:
            st.metric("Dimensi√≥n Embeddings", 768)

        st.dataframe(pinecone_df, use_container_width=True)

        if st.button("Actualizar Datos"):
            st.cache_data.clear()
            st.rerun()
    else:
        st.error("No se pudieron cargar los datos desde Pinecone")
        st.info("üí° Aseg√∫rate de haber inicializado la base de datos primero")
```


![Datos peliculas](./images/DatosPeliculas.png)

**5. Pesta√±a ‚ÄúVisualizaci√≥n de Embeddings‚Äù**

```python
Reduce los vectores v√≠a PCA para dibujar un gr√°fico 2D interactivo.

with tab3:
    st.header("Visualizaci√≥n de Embeddings")
    st.markdown("Representaci√≥n 2D de los embeddings usando PCA")

    if st.button("Generar Visualizaci√≥n"):
        with st.spinner("Calculando visualizaci√≥n..."):
            try:
                fig = demo.visualize_embeddings()
                st.plotly_chart(fig, use_container_width=True)
            except Exception as e:
                st.error(f"Error en visualizaci√≥n: {str(e)}")
```

![Grafico](./images/Grafico.png)

### Archivo config.py
El archivo config.py centraliza toda la configuraci√≥n necesaria para conectarse a Pinecone, gestionar las variables de entorno y obtener/crear un √≠ndice vectorial.

**1. Carga de dependencias y variables de entorno**

Este bloque importa las librer√≠as necesarias y carga autom√°ticamente el archivo .env que contiene la API key.

- dotenv permite usar variables como PINECONE_API_KEY.
- Evita exponer credenciales en el c√≥digo.
```python
import os
import time
from pinecone import Pinecone, ServerlessSpec
from dotenv import load_dotenv

load_dotenv()
```

**2. Clase PineconeConfig ‚Äì Inicializaci√≥n de Pinecone**

Esta clase encapsula toda la l√≥gica de conexi√≥n con Pinecone.

- Obtiene la API Key desde .env.
- Valida que exista.
- Crea el cliente oficial de Pinecone (Pinecone()).
Esto garantiza que cualquier m√≥dulo del proyecto pueda conectarse sin reescribir c√≥digo.
```python
class PineconeConfig:
    def __init__(self):
        self.api_key = os.getenv('PINECONE_API_KEY')
        if not self.api_key:
            raise ValueError("PINECONE_API_KEY no encontrada en variables de entorno")
        
        self.pc = Pinecone(api_key=self.api_key)
        print("Pinecone configurado correctamente")

```

**3. M√©todo get_index() ‚Äî (Crear o recuperar un √≠ndice)**

Este m√©todo administra el √≠ndice vectorial donde se almacenan las pel√≠culas.

```py
def get_index(self, index_name, dimension=384, metric='cosine', force_recreate=False):
    """Obtener o crear √≠ndice de Pinecone"""
    try:
        # Listar √≠ndices existentes
        existing_indexes = self.pc.list_indexes()
        index_names = [index.name for index in existing_indexes]
        
        print(f"√çndices existentes: {index_names}")
        
        if index_name not in index_names:
            print(f"Creando nuevo √≠ndice: {index_name} con dimensi√≥n {dimension}")
            self.pc.create_index(
                name=index_name,
                dimension=dimension,
                metric=metric,
                spec=ServerlessSpec(
                    cloud='aws',
                    region='us-east-1'
                )
            )
            print("Esperando a que el √≠ndice est√© listo...")
            time.sleep(10)
            print("√çndice creado y listo")
        else:
            print(f"Usando √≠ndice existente: {index_name}")
        
        return self.pc.Index(index_name)
        
    except Exception as e:
        print(f"Error al obtener √≠ndice: {e}")
        raise
```

### Archivo movie_recommender.py 

Este archivo contiene la clase principal MovieVectorDemo, responsable de:
- cargar los datos de pel√≠culas
- generar embeddings sem√°nticos
- subirlos a Pinecone
- realizar b√∫squedas vectoriales
- extraer datos para visualizaciones
- consultar Pinecone

**1. Inicializaci√≥n de la clase**
Crea el cliente de Pinecone usando PineconeConfig().
- Define el nombre del √≠ndice.
- Prepara variables internas para:
    - el dataframe de pel√≠culas
    el modelo de embeddings

```python
class MovieVectorDemo:
    def __init__(self):
        try:
            self.config = PineconeConfig()
            self.index_name = "movie-demo-semantic"
            self.movies_df = None
            self.embedding_model = None
            print("MovieVectorDemo inicializado correctamente")
        except Exception as e:
            print(f"Error al inicializar MovieVectorDemo: {e}")
            raise
```

**2. Cargar los datos desde CSV**
Carga el archivo movies.csv dentro del contenedor Docker.
- Asigna el contenido a self.movies_df.
- Este m√©todo debe ejecutarse siempre antes de generar embeddings.

```python
def load_sample_data(self):
    
    csv_path = "/app/data/movies.csv"
    self.movies_df = pd.read_csv(csv_path)
    print(f"{len(self.movies_df)} pel√≠culas cargadas desde CSV")
```

**3. Carga del modelo de embeddings**
- Carga un modelo SOTA de SentenceTransformers (all-mpnet-base-v2).
    -   Se utiliza para convertir pel√≠culas y consultas en vectores.

```python
def initialize_embedding_model(self):
    from sentence_transformers import SentenceTransformer
    self.embedding_model = SentenceTransformer('all-mpnet-base-v2')
```

**4. Generaci√≥n de embeddings**
- Combina t√≠tulo + g√©nero + descripci√≥n + keywords en un solo texto.
- Genera embeddings de manera vectorizada.
- Retorna un array (N, D) donde N es cantidad de pel√≠culas y D es la dimensi√≥n del embedding.

```python
def create_embeddings(self):
    if self.movies_df is None:
        self.load_sample_data()
    if self.embedding_model is None:
        self.initialize_embedding_model()

    combined_text = []
    for _, movie in self.movies_df.iterrows():
        text = f"{movie['title']}. {movie['genre']}. {movie['description']}"
        if 'keywords' in movie and pd.notna(movie['keywords']):
            text += f". {movie['keywords']}"
        combined_text.append(text)

    embeddings = self.embedding_model.encode(combined_text)
    print(f"Embeddings sem√°nticos creados: {embeddings.shape}")
    return embeddings
```

**5. Subir los vectores a Pinecone**
- Genera embeddings.
- Obtiene la dimensi√≥n real del modelo (importante para Pinecone).
- Recrea el √≠ndice desde cero si force_recreate=True.
- Prepara cada pel√≠cula en formato que reconozca pinecone y luego los inserta.

```python
def upload_to_pinecone(self):
    embeddings = self.create_embeddings()
    actual_dimension = embeddings.shape[1]

    index = self.config.get_index(
        self.index_name,
        dimension=actual_dimension,
        force_recreate=True
    )
```

**6. B√∫squeda sem√°ntica** 
- Convierte el texto de b√∫squeda en un embedding.
- Consulta Pinecone usando similitud coseno.
- Retorna los top_k resultados con metadatos.

```python
def search_similar_movies(self, query, top_k=3):
    if self.embedding_model is None:
        self.initialize_embedding_model()

    query_embedding = self.embedding_model.encode([query])[0]

    results = index.query(
        vector=query_embedding.tolist(),
        top_k=top_k,
        include_metadata=True
    )
    return results
```

**7. Visualizaci√≥n de embeddings**

Reduce los embeddings de N dimensiones ‚Üí 2D usando PCA.
- Crea un scatter plot interactivo con Plotly.
- Colorea por g√©nero y muestra hover con t√≠tulos.

```python
def visualize_embeddings(self):
    embeddings = self.create_embeddings()
    pca = PCA(n_components=2)
    embeddings_2d = pca.fit_transform(embeddings)
```

**8. Obtener todo el contenido del √≠ndice**

- Usa un vector cero para recuperar todos los elementos del √≠ndice.
- Convierte los resultados a un DataFrame.
- Se usa para la pesta√±a ‚ÄúDatos‚Äù en Streamlit.

```python
def get_all_movies_from_pinecone(self):
    zero_vector = [0] * actual_dimension

    results = index.query(
        vector=zero_vector,
        top_k=10000,
        include_metadata=True
    )
```

**9. Obtener el conteo de pel√≠culas**
- Devuelve cu√°ntos vectores hay actualmente en Pinecone.

```python
def get_movies_count(self):
    stats = index.describe_index_stats()
    return stats.total_vector_count
```


### C√≥mo ejecutar la demo
1. Ub√≠cate en el directorio ra√≠z del proyecto.

2. Levanta el contenedor utilizando Docker.

```
docker compose up --build
```
3. Entrar en el link:

```
http://localhost:8501/
```

### Link Video:

https://youtu.be/W2bA0UmyjrI







---

[‚¨ÖÔ∏è Anterior](../0.8.2/0.8.2.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../0.8.4/0.8.4.md)