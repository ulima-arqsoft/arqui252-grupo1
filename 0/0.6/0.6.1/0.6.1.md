> [0. Acerca del Grupo](../../0.md) ‚Ä∫ [0.6. Temas Individuales (Parte 1)](../0.6.md) ‚Ä∫ [0.6.1. Integrante 1](0.6.1.md)

# 0.6.1. Integrante 1

# Arquitectura de Microservicios

## 1. Desarrollo conceptual

### ¬øQu√© es la arquitectura de microservicios?

La **arquitectura de microservicios** es un estilo de dise√±o que divide una aplicaci√≥n en **servicios peque√±os, aut√≥nomos y desplegables de manera independiente**.  
Cada servicio implementa una **capacidad de negocio** concreta (por ejemplo, Usuarios, Productos, Pedidos) y se comunica con otros mediante **APIs ligeras** (REST/gRPC) o **mensajer√≠a** (Kafka/RabbitMQ).

**Caracter√≠sticas clave**

- **Desacoplamiento:** cambios en un servicio no rompen a los dem√°s.  
- **Despliegue independiente:** se actualiza o escala cada servicio de forma aislada.  
- **Propiedad del dato:** cada servicio gestiona su propia base de datos.  
- **Comunicaci√≥n ligera:** mediante HTTP/REST, gRPC o eventos.  
- **Organizaci√≥n por dominio:** alineada con *Bounded Contexts*.

**Ventajas**

- Escalabilidad selectiva, ciclos de entrega m√°s r√°pidos (CI/CD), resiliencia y equipos orientados a producto.

**Desaf√≠os**

- Mayor complejidad operativa (observabilidad, trazas distribuidas), consistencia eventual, latencia en red y gobierno de APIs.

---

### Ejemplo conceptual (e-commerce)

- **user-service:** autenticaci√≥n y gesti√≥n de usuarios  
- **product-service:** cat√°logo e inventario  
- **order-service:** orquestaci√≥n de pedidos (consume los otros dos)

**Diagrama general (alto nivel)**

+------------------+ HTTP +--------------------+
| user-service | <----------------> | order-service |
| :8081 | | :8083 (Feign) |
+------------------+ HTTP +--------------------+
^ ^
| |
| |
| HTTP |
+------------------+ |
| product-service | <----------------------------+
| :8082 |
+------------------+

---

## 2. Consideraciones t√©cnicas

**Stack elegido (profesional):**  
**Java 17 + Spring Boot 3**, con los siguientes componentes:

- **Spring Web:** para exponer APIs REST.  
- **OpenFeign:** para comunicaci√≥n entre servicios.  
- **Resilience4j:** para *retry* y *circuit breaker*.  
- **Actuator:** para *health checks* y monitoreo.  
- **Docker + Docker Compose:** para empaquetado y despliegue orquestado.  

> En la demo, cada servicio utiliza datos en memoria.  
> En un entorno real, cada microservicio tendr√≠a su propia base de datos y capa de persistencia independiente.

---

### Estructura del proyecto

microservices-spring/
‚îú‚îÄ user-service/
‚îÇ ‚îú‚îÄ pom.xml
‚îÇ ‚îî‚îÄ src/main/...
‚îú‚îÄ product-service/
‚îÇ ‚îú‚îÄ pom.xml
‚îÇ ‚îî‚îÄ src/main/...
‚îú‚îÄ order-service/
‚îÇ ‚îú‚îÄ pom.xml
‚îÇ ‚îî‚îÄ src/main/...
‚îî‚îÄ docker-compose.yml


### Puertos

| Servicio | Puerto |
|-----------|---------|
| user-service | 8081 |
| product-service | 8082 |
| order-service | 8083 |

### Endpoints principales

| Endpoint | Servicio | Descripci√≥n |
|-----------|-----------|--------------|
| `GET /users/{id}` | user-service | Obtiene informaci√≥n de usuario |
| `GET /products/{id}` | product-service | Obtiene datos del producto |
| `POST /orders` | order-service | Crea un pedido consumiendo los otros dos |

### Observabilidad

- Health check: `GET /actuator/health`  
- *(Opcional)*: m√©tricas con Micrometer / Prometheus / Grafana

---

## 3. Demo (C√≥digo)

### 3.1 Descripci√≥n general

Se implementaron tres microservicios en **Spring Boot 3.3.2**, desplegados mediante **Docker Compose**.  
El **order-service** se comunica con los otros dos a trav√©s de **Feign Clients**, utilizando **HTTP interno** dentro de la red de Docker.

Cada servicio tiene su propio `Dockerfile`, y el archivo `docker-compose.yml` orquesta su levantamiento conjunto.

---

### 3.2 C√≥digo y configuraci√≥n principal

#### user-service
Archivo `UserController.java`
```java
@RestController
@RequestMapping("/users")
public class UserController {
  private static final Map<Integer, User> DB = Map.of(
      1, new User(1, "Ana"),
      2, new User(2, "Luis")
  );

  @GetMapping("/{id}")
  public User byId(@PathVariable Integer id) {
    var u = DB.get(id);
    if (u == null) throw new NoSuchElementException("User not found");
    return u;
  }
}
```

#### product-service
Archivo `ProductController.java`
```java
@RestController
@RequestMapping("/products")
public class ProductController {
  private static final Map<Integer, Product> DB = Map.of(
      10, new Product(10, "Laptop", 2500.0),
      11, new Product(11, "Mouse", 80.0)
  );

  @GetMapping("/{id}")
  public Product byId(@PathVariable Integer id) {
    var p = DB.get(id);
    if (p == null) throw new NoSuchElementException("Product not found");
    return p;
  }
}
```

#### order-service
Archivo `OrderController.java`
```java
@RestController
@RequestMapping("/orders")
public class OrderController {
  private final UserClient userClient;
  private final ProductClient productClient;

  public OrderController(UserClient userClient, ProductClient productClient) {
    this.userClient = userClient;
    this.productClient = productClient;
  }

  @PostMapping
  @Retry(name = "default")
  @CircuitBreaker(name = "default", fallbackMethod = "fallback")
  public ResponseEntity<OrderDto> create(@RequestBody Map<String, Integer> body) {
    var user = userClient.getById(body.get("userId"));
    var product = productClient.getById(body.get("productId"));
    var order = new OrderDto(System.currentTimeMillis(), user, product, product.price(), "CREATED");
    return ResponseEntity.status(201).body(order);
  }

  public ResponseEntity<OrderDto> fallback(Map<String, Integer> body, Throwable t) {
    return ResponseEntity.status(503).build();
  }
}
```

### 3.3 Docker Compose
Archivo `docker-compose.yml`

```yaml
version: "3.8"
services:
  user-service:
    build: ./user-service
    ports: ["8081:8080"]

  product-service:
    build: ./product-service
    ports: ["8082:8080"]

  order-service:
    build: ./order-service
    ports: ["8083:8080"]
    depends_on:
      - user-service
      - product-service
```

### 3.4 Ejecuci√≥n

## 3.4.1 Compilar los tres servidores

```bash
mvn -q -DskipTests package -f user-service/pom.xml
mvn -q -DskipTests package -f product-service/pom.xml
mvn -q -DskipTests package -f order-service/pom.xml
```

## 3.4.2 Construir y levantar contenedores

```bash
docker compose up --build
```

## 3.4.3 Verificar endpoints

```bash
curl http://localhost:8081/users/1
curl http://localhost:8082/products/10
curl -X POST http://localhost:8083/orders -H "Content-Type: application/json" -d "{\"userId\":1,\"productId\":10}"
```

### 3.5 Prueba de resiliencia

Si se detiene el product-service, el order-service activa su circuit breaker de Resilience4j devolviendo 503 Service Unavailable, demostrando tolerancia ante fallos.

```bash
docker stop product-service
curl -X POST http://localhost:8083/orders -H "Content-Type: application/json" -d "{\"userId\":1,\"productId\":10}"
# -> Respuesta: 503 (fallback activado)
```

### 3.6 Video

En el video se mostrar√°:

- Ejecuci√≥n de los tres microservicios con Docker Compose.
- Pruebas de endpoints (GET, POST).
- Comunicaci√≥n entre servicios (Feign).
- Manejo de error con Resilience4j.

Ver video de la demo: 

---

[‚¨ÖÔ∏è Anterior](../0.6.2/0.6.2.md) | [üè† Home](../../../README.md) | [Siguiente ‚û°Ô∏è](../0.6.4/0.6.4.md)